---
title: "COBP_IPM_analysis"
author: "Alice Stears"
date: "11/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
#load packages
library(tidyverse)
```
# Background
### *Oenothera coloradensis* life-cycle diagram
![Figure of the O. coloradensis life-cycle, with transitions labeled](images/COBP_lifecyclediagram.jpg)

### Functions in the IPM kernel
For data from a pre-reproductive census, with a discrete seedling and seedbank stages 

$n(z',t+1) = $

**Growth:**
$$P(z',z) = \int_{L}^{U}(1-p_b(z))s(z)G(z',z)n(z,t)dz$$
plus ... 

**Fecundity:** With a time lag for flowering probability and 
$$F(z',z) = C_0(z') \Big[p_{germ}\int_{L}^{U}p_b(z)n(z,t-1)dz+p_{SBout}B(t) \Big] $$

**Seedbank:**   (after Ellner, 2016)
$$B(t+1) = s_{B}\Big[(1-\gamma)B(t)+\delta\int_{L}^{U}p_b(z)b(z)n(z,t)dz \Big]$$

# Load *Oenothera coloradensis* census data
```{r}
dat <- read.csv("../Raw Data/COBP_long_CURRENT.csv")
```
## transform the necessary variables
```{r}
#### make log-transformed size variables ####
dat$log_LL_t <- log(dat$LongestLeaf_cm)
dat$log_LL_tplus1 <- log(dat$longestLeaf_tplus1)
dat$log_LL_tminus1 <- log(dat$longestLeaf_tminus1)

#### round seed count numbers (that were modeled based on regression) to whole numbers ####
dat$Num_capsules <- round(dat$Num_capsules, digits = 0)
```

# Make vital rate models 
### Survival
```{r}
## subset the data to exclude flowering individuals
survDat <- dat[dat$flowering==0 | is.na(dat$flowering),]

# ## visualize the data
# plot(survives_tplus1 ~ log_LL_t, data = survDat)

## logistic glm with log-transformed size_t
survMod <- glm(survives_tplus1 ~ log_LL_t, data = survDat, family = binomial)
summary(survMod)
## plot model results 
plot(survives_tplus1 ~ log_LL_t, data = survDat)
newdata <- data.frame("log_LL_t" = seq(from = min(survDat$log_LL_t, na.rm = TRUE), 
               to = max(survDat$log_LL_t, na.rm = TRUE),
               length.out = 100))
lines(x = newdata$log_LL_t, y = predict(object = survMod, newdata =  newdata, type = "response"), col = "red")
```

### Growth
```{r}
# ## visualize the data
# plot(log_LL_tplus1 ~ log_LL_t, data = dat)

## lm w/ log-transformed size_t and size_t+1
sizeMod <- lm(log_LL_tplus1 ~ log_LL_t , data = dat)
summary(sizeMod)
## plot model results
plot(log_LL_tplus1 ~ log_LL_t, data = dat)
abline(sizeMod, col = "red")
```

### Fecundity 
using size in current year (no. of seeds/plant, for those that flowered ~ size_t)
```{r}
 ## use only plants that flowered 
 seedDat <- dat[dat$flowering==1,]

# ## visualize the data
# plot(Num_capsules ~ log_LL_t, data = seedDat)

## fit poisson glm (for count data)
seedMod_t <- glm(Num_capsules ~ log_LL_t, data = seedDat, family = poisson)
summary(seedMod_t)
## plot model results
plot(Num_capsules ~ log_LL_t, data = seedDat)
newdata <- data.frame("log_LL_t" = seq(from = min(seedDat$log_LL_t, na.rm = TRUE), 
                                       to = max(seedDat$log_LL_t, na.rm = TRUE),
                                       length.out = 100))
lines(x = newdata$log_LL_t, y = predict(object = seedMod_t, newdata =  newdata, type = "response"), col = "red")
```

### Fecundity
using size in previous year (no. of seeds/plant, for those that flowered ~ size_tminus1)
```{r}
## fit poisson glm (for count data)
seedMod_tminus1 <- glm(Num_capsules ~ log_LL_tminus1, data = seedDat, family = poisson)
summary(seedMod_tminus1)
## plot model results
plot(Num_capsules ~ log_LL_tminus1, data = seedDat)
newdata <- data.frame("log_LL_tminus1" = seq(from = min(seedDat$log_LL_tminus1, na.rm = TRUE), 
                                       to = max(seedDat$log_LL_tminus1, na.rm = TRUE),
                                       length.out = 100))
lines(x = newdata$log_LL_tminus1, y = predict(object = seedMod_tminus1, newdata =  newdata, type = "response"), col = "red")

```

### Flowering probability
using size in current year
```{r}
## logistic glm with log-transformed size_t
flwrMod_t <- glm(flowering ~ log_LL_t, data = dat, family = binomial)
summary(flwrMod_t)
## plot model results 
plot(flowering ~ log_LL_t, data = dat)
newdata <- data.frame("log_LL_t" = seq(from = min(dat$log_LL_t, na.rm = TRUE), 
                                       to = max(dat$log_LL_t, na.rm = TRUE),
                                       length.out = 100))
lines(x = newdata$log_LL_t, y = predict(object = flwrMod_t, newdata =  newdata, type = "response"), col = "red")
```

### Flowering probability
using size in previous year
```{r}

## visualize the data
plot(flowering ~ log_LL_tminus1, data = dat)

## logistic glm with log-transformed size_t
flwrMod_tminus1 <- glm(flowering ~ log_LL_tminus1, data = dat, family = binomial)
summary(flwrMod_tminus1)
## plot model results 
plot(flowering ~ log_LL_tminus1, data = dat)
newdata <- data.frame("log_LL_tminus1" = seq(from = min(dat$log_LL_tminus1, na.rm = TRUE), 
                                       to = max(dat$log_LL_tminus1, na.rm = TRUE),
                                       length.out = 100))
lines(x = newdata$log_LL_tminus1, y = predict(object = flwrMod_tminus1, newdata =  newdata, type = "response"), col = "red")
```

### Distribution of recruit size
```{r}
## subset the data
recD <- dat[dat$age == 0 & is.na(dat$age) == FALSE,]

recMod <- lm(log_LL_t ~ 1, data = recD)
summary(recMod)

hist(recD$log_LL_t)
abline(v = recMod$coefficients, col = "blue", lwd = 2)
```

### Probability of establishment (and surviving through the seedbank stage)
```{r message=FALSE}
## make a column in 'dat' that labels recruits
dat$recruit <- 0
dat[dat$age==0 & is.na(dat$age)==FALSE,"recruit"] <- 1
## get the number of recruits/year 
estabTemp <- dat %>% 
  select(Plot_ID, Year, Num_capsules, seedling, recruit) %>% 
  group_by(Plot_ID, Year) %>% 
  summarize(seeds = sum(Num_capsules, na.rm = TRUE), recruits = sum(recruit)) %>% 
  rename(seeds_t = seeds, recruits_t = recruits) 

## get the no.of seeds/year
seedsTemp <- estabTemp %>% 
  select(Plot_ID, Year, seeds_t)

## get the no. of recruits/year t-2 (since we're including the seedling stage in this step)
recsTemp <- estabTemp %>% 
  select(Plot_ID, Year, recruits_t) %>% 
  rename(recruits_tplus1 = recruits_t) %>% 
  mutate(Year = Year - 2)

estabs <- left_join(seedsTemp, recsTemp)

## calculate the 
temp <- estabs$recruits_tplus1/estabs$seeds_t
temp[is.infinite(temp)] <- NA
(p.r.est <- mean(temp, na.rm = TRUE))
```

### Probability of a seed produced by an adult plant in year t will germinate in year t+1 (i.e. skipping the seedbank) (Pgerm)

### Probability of a seed produced by an adult plant in year t will enter the seedbank in year t+1 (PgoSB)

###Probability that a seed in the seedbank in year t will exit the seedbank in year t+1 (PSBout)

### Probability that a seed in the seedbank in year t will stay in the seedbank as a viable seed in year t+1 (PSBstay)

## Note: Vital rates #1 and #2, and #3 and #4 do not need to sum to 1. The remainder of each of these pairs accounts for seed mortality between years.  


## Implement the IPM 
### Write the demography functions

### Growth function, given you are size z (now returns the pdf of size z1 in the next year)
```{r}
G_z1z <- function(z1, z, m.par)
{
  mu <- m.par["grow.int"] + m.par["grow.z"] * z           # mean size next year
  sig <- m.par["grow.sd"]                                    # sd about mean
  p.den.grow <- dnorm(z1, mean = mu, sd = sig)             # pdf that you are size z1 given you were size z
  return(p.den.grow)
}
```

###  Survival function, logistic regression
```{r}
s_z <- function(z, m.par)
{
  linear.p <- m.par["surv.int"] + m.par["surv.z"] * z  # linear predictor
  p <- 1/(1+exp(-linear.p))                            # logistic transformation to probability
  return(p)
}
```


### Probability of flowering function, logistic regression
```{r}
p_bz <- function(z, m.par)
{
  linear.p <- m.par["flow.int"] + m.par["flow.z"] * z      # linear predictor
  p <- 1/(1+exp(-linear.p))                                # logistic transformation to probability
  return(p)
}
```

### Seed production function
```{r}
b_z <- function(z, m.par)
{
  N <- exp(m.par["seed.int"] + m.par["seed.z"] * z)    # seed production of a size z plant
  return(N)
}
```

### Recruit size pdf
```{r}
c_0z1 <- function(z1, m.par)
{
  mu <- m.par["rcsz.int"]
  sig <- m.par["rcsz.sd"]
  p.deRecr <- dnorm(z1, mean = mu, sd = sig)              # pdf of a size z1 recruit
  return(p.deRecr)
}
```

### Define the survival kernel
```{r}
P_z1z <- function (z1, z, m.par) {
  
  return((1 - p_bz(z, m.par)) * s_z(z, m.par) * G_z1z(z1, z, m.par))
  
}
```

### Define the fecundity kernel
```{r}
F_z1z <- function (z1, z, m.par) {
  
  return( p_bz(z, m.par) * b_z(z, m.par) * m.par["p.r"] * c_0z1(z1, m.par))
  
}
```

### write the IPM kernel function
```{r}
mk_K <- function(m, m.par, L, U) {
  
  # mesh points 
  h <- (U - L)/m
  meshpts <- L + ((1:m) - 1/2) * h
  P <- h * (outer(meshpts, meshpts, P_z1z, m.par = m.par))
  F <- h * (outer(meshpts, meshpts, F_z1z, m.par = m.par))
  K <- P + F
  return(list(K = K, meshpts = meshpts, P = P, F = F))
}


# flexible size limits, defaults set for Oenothera model
mk_K_ceiling <- function(m, m.par, L, U, U1 = U) {
  # mesh points 
  h <- (U - L)/m;
  meshpts <- L + ((1:m) - 1/2) * h;
  P <- h * (outer(meshpts, pmin(meshpts,U1), P_z1z, m.par = m.par));
  F <- h * (outer(meshpts, pmin(meshpts,U1), F_z1z, m.par = m.par));
  K <- P + F;
  return(list(K = K, meshpts = meshpts, P = P, F = F))
}
```

Additional functions to calculate lambdas and project vital rates
```{r}
#Function to calculate mean and variance in reproductive output for a size z

get_mean_var_Repr <- function(init.z,n.samp) {
  
  # initial population sizes and ages
  z   <- rep(init.z,1000)
  Repr.out <- NULL
  
  repeat {
    
    ## calculate population size
    pop.size <- length(z)
    
    ## generate binomial random number for the probability of flowering, where the probability of flowering
    ## depends on your size z, this is a vector of 0's and 1's, you get a 1 if you flower
    Repr <- rbinom(n=pop.size, prob=p_bz(z, m.par.true), size=1)
    
    ## number of plants that flowered
    num.Repr <- sum(Repr)
    
    if(num.Repr>0) {
      Seeds <- rpois(num.Repr, m.par.true["p.r"] * b_z(z[Repr==1],m.par.true))
      Repr.out <- c(Repr.out,Seeds)
    }
    
    ## generate new recruit sizes
    ## rnorm generated normally distributed random numbers
    Rcsz <- rep(init.z,100)
    
    ## for the non-reproductive plants generate random number for survival
    Surv <- rep(NA, pop.size)
    Surv[Repr==0] <- rbinom(n = pop.size - num.Repr, prob = s_z(z[Repr==0], m.par.true), size = 1)
    num.die <- sum(Surv==0, na.rm=TRUE)
    
    if(num.die>0) Repr.out <- c(Repr.out,rep(0,num.die))
    
    ## index for individuals that did not flower and survived
    i.subset <- which(Repr==0 & Surv==1)
    
    ## let them grow
    E.z1 <- m.par.true["grow.int"]+m.par.true["grow.z"]*z[i.subset]
    z1 <- rnorm(n = pop.size - num.Repr - num.die, mean = E.z1, sd = m.par.true["grow.sd"])
    
    z <- c(Rcsz, z1)
    
    if(length(Repr.out)>n.samp) break
    
  }
  
  return(c(mean(Repr.out),var(Repr.out),mean(Repr.out>0),var(Repr.out>0)))
  
}
```

## Actually fit the IPM to the COBP data

### specify coefficients from models above
(using *t* for flowering and fecundity)
```{r}
## get vital rate model coefficients
m.par.est <- c(surv = coef(survMod),
               flow = coef(flwrMod_t),
               grow = coef(sizeMod),
               grow.sd = summary(sizeMod)$sigma,
               rcsz = coef(recMod),
               rcsz.sd = summary(recMod)$sigma,
               seed = coef(seedMod_t),
               p.r = p.r.est
               )
names(m.par.est) <- c("surv.int", "surv.z", "flow.int", "flow.z",  "grow.int", "grow.z",   "grow.sd" , "rcsz.int", "rcsz.sd" , "seed.int", "seed.z"  , "p.r"   )  

## prepare the matrix
nBigMatrix <- 250
min.size <- with(dat, min(log_LL_t, na.rm = TRUE))
min.size
max.size <- with(dat, max(log_LL_t, na.rm = TRUE))
max.size

## fit the IPM
IPM.est <- mk_K(nBigMatrix, m.par.est, -3, 4)

## cube the K matrix?
IPM.cube <- (IPM.est$K)^3
```

### Visualize the IPM kernel
```{r echo = FALSE}
## matrix function, from Ellner
matrix.image=function(A, x=NULL, y=NULL, col=rainbow(100,start=0.67,end=0),
             bw=FALSE, do.contour=FALSE, do.legend=TRUE,...) {
 if(do.legend) layout(mat=cbind(matrix(1,5,5),rep(2,5)));
 par(mar=c(6,5,3,2)); 
 if(is.null(x)) x=1:ncol(A);
 if(is.null(y)) y=1:nrow(A); 
 nx=length(x); ny=length(y); 
 x1=c(1.5*x[1]-0.5*x[2],1.5*x[nx]-0.5*x[nx-1]); 
 y1=c(1.5*y[1]-0.5*y[2],1.5*y[ny]-0.5*y[ny-1]); 
 if(bw) col=grey( (200:50)/200 ); 
 image(list(x=x,y=y,z=t(A)),xlim=x1,ylim=rev(y1),col=col,cex.axis=1.5,cex.lab=1.5,bty="u",...);
 abline(v=range(x1)); abline(h=range(y1)); 
 if(do.contour) contour(x,y,t(A),nlevels=5,labcex=1.2,add=TRUE);   
 
 if(do.legend) {
    l.y=seq(min(A),max(A),length=100);  
    par(mar=c(6,2,3,1))
    image(list(x=1:2,y=l.y,z=rbind(l.y,l.y)),col=col,bty="o",xaxt="n",yaxt="n"); 
    axis(side=2,cex.axis=1.5,at=pretty(seq(min(A),max(A),length=10))); 
 } 
}
```

```{r}
image(IPM.est$meshpts,IPM.est$meshpts, t(IPM.est$P + IPM.est$F)^.1)
```

## Calculate projected vital rates and lambdas
```{r}
Re(eigen(IPM.est$K)$values[1])
```
modeled asymptotic rate of increase : 0.69

```{r}
pop.size <- dat %>% 
  select(Year, log_LL_t) %>% 
  group_by(Year) %>% 
  summarize(pop.size = n(), mean.size = mean(log_LL_t, na.rm = TRUE))

fit.pop.growth <- lm(log(pop.size$pop.size) ~ pop.size$Year)

exp(coef(fit.pop.growth)[2])
```
true finite rate of increase: 1.01
